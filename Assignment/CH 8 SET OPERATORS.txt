1 DISPLAY THOSE EXISTING EMPLOYEE_ID WHO HAVE GOT PROMOTION.  // EMPLOYEE_ID SHOULD BOTH BE IN JOB_HISTORY AND EMPLOYEES TABLE
SELECT FIRST_NAME FROM EMPLOYEES
WHERE EMPLOYEE_ID IN
(SELECT EMPLOYEE_ID FROM EMPLOYEES
INTERSECT
SELECT EMPLOYEE_ID FROM JOB_HISTORY);
  
2 DISPLAY THOSE EMPLOYEE_ID WHO HAVE LEFT THE COMPANY.    //EMPLOYEE_ID SHOULD BE IN JOB_HISTORY BUT NOT IN EMPLOYEES TABLE     (LOGICALLY THINK AND BELIEVE!!!!!!)
SELECT EMPLOYEE_ID FROM JOB_HISTORY
MINUS
SELECT EMPLOYEE_ID FROM EMPLOYEES;

3 DISPLAY ALL FIRST_NAME AND DEPARTMENT_NAME IN SINGLE RESULT SET WITH PROPER COLUMN HEADING.
SELECT FIRST_NAME "FIRST_NAME AND DEPARTMENT_NAME" FROM EMPLOYEES  
UNION ALL
SELECT DEPARTMENT_NAME FROM DEPARTMENTS;

4 DISPLAY DEPARTMENT_ID IN WHICH NO EMPLOYEE IS HIRED.   // CONTRACTING WALI DEPARTMENT_ID LANI HAI         OP !!!!!!!!! LOGICALLY THINK JUST
SELECT DEPARTMENT_ID FROM DEPARTMENTS
MINUS
SELECT DEPARTMENT_ID FROM EMPLOYEES;
  
5 DISPLAY THOSE REGION_ID IN WHICH NO LOCATION EXISTS.  // LOGIC
SELECT REGION_ID FROM REGIONS
MINUS
SELECT REGION_ID FROM COUNTRIES;

USING OUTER JOIN ALSO -- VIRAL MODI

SELECT REGION_ID FROM REGIONS                 // JODD BOLTE!!
LEFT JOIN COUNTRIES USING(REGION_ID) WHERE COUNTRY_NAME IS NULL;
  
6 DISPLAY GRADE_LEVEL IN WHICH NO EMPLOYEE IS GETTING SALARY.    // SAARE GRADE_LEVEL MAI SE JISKO SALARY MIL RHI WALE GRADE_LEVEL KO MINUS KARDO
SELECT GRADE_LEVEL FROM JOB_GRADES
MINUS
SELECT GRADE_LEVEL FROM EMPLOYEES JOIN JOB_GRADES ON SALARY BETWEEN LOWEST_SAL AND HIGHEST_SAL;

USING OUTER JOIN OP!!!!!!

SELECT GRADE_LEVEL FROM JOB_GRADES
LEFT JOIN EMPLOYEES ON SALARY BETWEEN LOWEST_SAL AND HIGHEST_SAL WHERE FIRST_NAME IS NULL;
  
7 DISPLAY COUNTRY_ID IN WHICH NO LOCATION EXISTS. // OP!!!!!!!!!!
SELECT COUNTRY_NAME FROM COUNTRIES
WHERE COUNTRY_ID IN
(SELECT COUNTRY_ID FROM COUNTRIES
MINUS
SELECT COUNTRY_ID FROM LOCATIONS);
 
8 DISPLAY ONLY THOSE DEPARTMENT_NAME IN WHICH EMPLOYEES ARE WORKING.
SELECT DEPARTMENT_NAME FROM DEPARTMENTS
WHERE DEPARTMENT_ID IN
(SELECT DEPARTMENT_ID FROM EMPLOYEES
INTERSECT
SELECT DEPARTMENT_ID FROM DEPARTMENTS);

9 DISPLAY THOSE EXISTING EMPLOYEE'S FIRST_NAME WHO HAVE NOT GOT ANY PROMOTION. // EMPLOYEES MAI HONE CHAHIYE BUT NOT IN JOB_HISTORY SO MINUS HONA CHAHIYE
SELECT FIRST_NAME FROM EMPLOYEES
WHERE EMPLOYEE_ID IN
(SELECT EMPLOYEE_ID FROM EMPLOYEES
MINUS
SELECT EMPLOYEE_ID FROM JOB_HISTORY);
 
10 DISPLAY ONLY THOSE COUNTRY_NAME IN WHICH LOCATION EXISTS.    // INTERSECT BOLTE!
SELECT COUNTRY_NAME FROM COUNTRIES
WHERE COUNTRY_ID IN
(SELECT COUNTRY_ID FROM COUNTRIES
INTERSECT
SELECT COUNTRY_ID FROM LOCATIONS);

11 DISPLAY ONLY THOSE REGION_NAME IN WHICH COUNTRY EXISTS.        // INTERSECT BOLTE!
SELECT REGION_NAME FROM REGIONS
WHERE REGION_ID IN
(SELECT REGION_ID FROM COUNTRIES
INTERSECT
SELECT REGION_ID FROM REGIONS);

12 DISPLAY THOSE JOB_ID FOR WHICH EMPLOYEES WERE HIRED UNTIL YEAR 95, BUT NOT AFTER THAT.
SELECT JOB_ID FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'RR')<=95
UNION
SELECT JOB_ID FROM EMPLOYEES WHERE NOT(TO_CHAR(HIRE_DATE,'RR')>95);

13 DISPLAY THOSE JOB_ID FOR WHICH EMPLOYEES WERE HIRED UNTIL YEAR 95, AS WELL AS AFTER 95.
SELECT JOB_ID FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'RR')<=95
UNION
SELECT JOB_ID FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'RR')>95;

14 DISPLAY DEPARTMENT_ID FOR WHICH COMPANY HIRED EMPLOYEES IN FIRST HALF OF ANY YEAR AS WELL AS SECOND HALF OF ANY YEAR.
SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE SUBSTR(ROUND(HIRE_DATE,'RR'),8,2)=SUBSTR(TRUNC(HIRE_DATE,'RR'),8,2)
UNION
SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE SUBSTR(ROUND(HIRE_DATE,'RR'),8,2)=SUBSTR(TRUNC(HIRE_DATE,'RR'),8,2)+1;

SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE TRUNC(HIRE_DATE,'RR')=ROUND(HIRE_DATE,'RR')
UNION
SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE TRUNC(HIRE_DATE,'RR')!=ROUND(HIRE_DATE,'RR');

15 DISPLAY DEPARTMENT_ID FOR WHICH COMPANY HIRED EMPLOYEES IN FIRST HALF OF ANY YEAR BUT NOT IN SECOND HALF OF ANY YEAR.  // OP QUES LOGIC IS BOHOTTT HARD!!!!!
SELECT DEPARTMENT_ID,HIRE_DATE FROM EMPLOYEES WHERE SUBSTR(ROUND(HIRE_DATE,'RR'),8,2)=SUBSTR(TRUNC(HIRE_DATE,'RR'),8,2)
UNION
SELECT DEPARTMENT_ID,HIRE_DATE FROM EMPLOYEES WHERE SUBSTR(ROUND(HIRE_DATE,'RR'),8,2)!=SUBSTR(TRUNC(HIRE_DATE,'RR'),8,2)+1;

16 DISPLAY JOB_ID FOR WHICH EMPLOYEE GETS SALARY UPTO 8000 AS WELL AS MORE THAN 8000.
SELECT JOB_ID FROM EMPLOYEES WHERE SALARY <=8000
UNION 
SELECT JOB_ID FROM EMPLOYEES WHERE SALARY >8000;

17 DISPLAY JOB_ID FOR WHICH EMPLOYEE GETS SALARY UPTO 8000 BUT NOT MORE THAN 8000.
SELECT FIRST_NAME,SALARY FROM EMPLOYEES
MINUS
SELECT FIRST_NAME,SALARY FROM EMPLOYEES WHERE SALARY>8000;

18 DISPLAY JOB_ID FOR WHICH EMPLOYEE GETS SALARY MORE THAN 10000 BUT NOT UPTO 10000.
SELECT FIRST_NAME,SALARY FROM EMPLOYEES
MINUS
SELECT FIRST_NAME,SALARY FROM EMPLOYEES WHERE SALARY<=10000;

19 DISPLAY DEPARTMENT_ID , MANAGER_ID FOR THOSE EMPLOYEES WHO REPORT TO HIS DEPARTMENT HEAD.
SELECT FIRST_NAME FROM EMPLOYEES
WHERE (MANAGER_ID,DEPARTMENT_ID) IN
(SELECT MANAGER_ID,DEPARTMENT_ID FROM EMPLOYEES
INTERSECT
SELECT MANAGER_ID,DEPARTMENT_ID FROM DEPARTMENTS);

20 DISPLAY DEPARTMENT_ID , MANAGER_ID FOR THOSE EMPLOYEES WHO DOESN'T REPORT TO HIS DEPARTMENT HEAD.
SELECT FIRST_NAME FROM EMPLOYEES
WHERE (MANAGER_ID,DEPARTMENT_ID) NOT IN
(SELECT MANAGER_ID,DEPARTMENT_ID FROM EMPLOYEES
INTERSECT
SELECT MANAGER_ID,DEPARTMENT_ID FROM DEPARTMENTS);

LOGIC TWO:-
SELECT FIRST_NAME FROM EMPLOYEES                        // DOES'NT REPORT TO DEPARTMENT HEAD MTLB DEPARTMENTS TABLE MAI MANAGER_ID NAHI HONGI USKI
WHERE (MANAGER_ID,DEPARTMENT_ID) IN
(SELECT MANAGER_ID,DEPARTMENT_ID FROM EMPLOYEES
MINUS
SELECT MANAGER_ID,DEPARTMENT_ID FROM DEPARTMENTS);      // OP!!

21 DISPLAY THOSE JOB_ID FOR WHICH EMPLOYEES WERE HIRED IN ODD QUARTERS BUT NOT IN EVEN QUARTERS. (IGNORE YEAR)
SELECT FIRST_NAME,TO_CHAR(HIRE_DATE,'Q'),JOB_ID FROM EMPLOYEES WHERE MOD(TO_CHAR(HIRE_DATE,'Q'),2)^=0
MINUS
SELECT FIRST_NAME,TO_CHAR(HIRE_DATE,'Q'),JOB_ID FROM EMPLOYEES WHERE MOD(TO_CHAR(HIRE_DATE,'Q'),2)=0;

SECOND LOGIC!!!!!!!

SELECT FIRST_NAME,TO_CHAR(HIRE_DATE,'Q'),JOB_ID FROM EMPLOYEES 
INTERSECT 
SELECT FIRST_NAME,TO_CHAR(HIRE_DATE,'Q'),JOB_ID FROM EMPLOYEES  WHERE TO_CHAR(HIRE_DATE,'Q') IN (1,3);

==========================================================
FOR SOLVING BELOW QUESTIONS USE MPSEMP AND MPSDEPT TABLES.
==========================================================

22 DISPLAY ALL JOBS INCLUDING DUPLICATE FOR DEPTNO 20 AND 30.   // INCLUDING DUPLICATE IS GIVEN SO UNION ALL!!!!!
SELECT JOB FROM MPSEMP WHERE DEPTNO=20
UNION ALL
SELECT JOB FROM MPSEMP WHERE DEPTNO=30;

23 DISPLAY ALL DISTINCT JOB FOR WHICH EMPLOYEES ARE HIRED IN BOTH DEPTNO 10 AND 30.   // USE CONCEPT OF MINUS BOLTE!!!!
SELECT JOB FROM MPSEMP WHERE DEPTNO=10
MINUS
SELECT JOB FROM MPSEMP WHERE DEPTNO=30
UNION
(SELECT JOB FROM MPSEMP WHERE DEPTNO=30
MINUS
SELECT JOB FROM MPSEMP WHERE DEPTNO=10);

24 DISPLAY ALL DNAME AND LOC IN SINGLE COLUMN (ONE ABOVE THE OTHER) WITH PROPER COLUMN HEADING.
SELECT DNAME "DNAME AND LOC" FROM MPSDEPT
UNION
SELECT LOC FROM MPSDEPT;

25 DISPLAY ONLY THOSE JOBS FOR WHICH EMPLOYEES ARE HIRED IN DEPTNO 30 BUT NOT FOR REMAINING DEPARTMENTS.
SELECT JOB FROM MPSEMP WHERE DEPTNO=30
MINUS
SELECT JOB FROM MPSEMP WHERE DEPTNO=20
MINUS
SELECT JOB FROM MPSEMP WHERE DEPTNO=10;

OR

SELECT JOB FROM MPSEMP WHERE DEPTNO=30
MINUS
(SELECT JOB FROM MPSEMP WHERE DEPTNO=20
UNION
SELECT JOB FROM MPSEMP WHERE DEPTNO=10);

26 DISPLAY ALL JOBS OF DEPTNO 10 AND 20 WHICH ARE NOT PRESENT IN DEPTNO 30.(UNION 10 AND 20 AND MINUS 30 FROM IT SIMPLE BOLTE!!!) OP!!!!!!
SELECT JOB FROM MPSEMP WHERE DEPTNO=10
UNION
SELECT JOB FROM MPSEMP WHERE DEPTNO=20
MINUS
SELECT JOB FROM MPSEMP WHERE DEPTNO=30;

27 DISPLAY ONLY THOSE JOBS FOR WHICH COMPANY HAS HIRED EMPLOYEES ON BOTH YEARS 1981 AND 1982.
SELECT JOB FROM MPSEMP WHERE TO_CHAR(HIREDATE,'RRRR')=1981
UNION
SELECT JOB FROM MPSEMP WHERE TO_CHAR(HIREDATE,'RRRR')=1982;

28 (EMPLOYEES TABLE)DISPLAY THOSE JOBS FOR WHICH COMPANY HAS HIRED EMPLOYEES IN BOTH 1996 AND 1998 BUT NOT IN 1999.
SELECT FIRST_NAME FROM EMPLOYEES
INTERSECT
SELECT FIRST_NAME FROM EMPLOYEES WHERE TO_CHAR(HIRE_DATE,'RR') IN (96,98);

29 DISPLAY STAFF, SUBJECT AND COLUMN NAMED CAN. WHICH SHOULD DISPLAY YES OR NO, BASED ON STAFF CAN TEACH THE SUBJECT OR NOT.

LOGIC USED IS -> FIRST WE WILL TAKE ALL THE STAFF WITH THEIR SUBJECTS AS NO AND AFTER THAT WE WILL REMOVE THE DUPLICATE NO FROM MPSCANTEACH
AND THAN COMBINE IT WITH YES FROM MPSCANTEACH

SELECT T.NAME STAFF,B.NAME SUBJECT,'NO' "CAN?" FROM MPSSTAFF T CROSS JOIN MPSSUBJECT B
MINUS
SELECT STAFF,SUBJECT,'NO' FROM MPSCANTEACH
UNION 
SELECT STAFF,SUBJECT,'YES' FROM MPSCANTEACH;

30 DISPLAY JOB_ID AND SUM OF SALARY PAID TO EACH JOB AND DEPTNO AND NO. EMPLOYEES WORKS FOR EACH DEPTNO ONE ABOVE THE ANOTHER IN SINGLE RESULT SET. SORT RESULT ON LAST COLUMN.
SELECT JOB_ID,SUM(SALARY) FROM EMPLOYEES GROUP BY JOB_ID
UNION
SELECT TO_CHAR(DEPARTMENT_ID),COUNT(*) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;

31 DEVELOP ENAME AND EMPNO AS FIRST RESULT SET. DNAME AS SECOND RESULT SET AND CLUB BOTH VERTICALLY.
SELECT ENAME,EMPNO FROM MPSEMP
UNION
SELECT DNAME,NULL FROM MPSDEPT;

32 DEVELOP DEPTNO AND HIREDATE AS FIRST RESULT SET. ENAME AND DEPTNO AS SECOND RESULT SET. DISPLAY THEM AS SINGLE RESULT SET.     // JODDDDD BOLTE BEY!!!!!
SELECT TO_CHAR(DEPTNO),TO_CHAR(HIREDATE) FROM MPSEMP
UNION
SELECT ENAME,TO_CHAR(DEPTNO) FROM MPSEMP;
